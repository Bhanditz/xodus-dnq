package jetbrains.teamsys.dnq.runtime.events;

/*Generated by MPS */

import com.jetbrains.teamsys.database.TransientStoreSessionListener;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.Map;
import com.jetbrains.teamsys.database.EntityId;
import java.util.List;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import com.jetbrains.teamsys.core.dataStructures.hash.HashMap;
import org.jetbrains.annotations.Nullable;
import java.util.Set;
import com.jetbrains.teamsys.database.TransientEntityChange;
import jetbrains.teamsys.dnq.runtime.util.DnqUtils;
import com.jetbrains.teamsys.database.TransientStoreSession;
import com.jetbrains.teamsys.dnq.database.TransientStoreUtil;
import com.jetbrains.teamsys.database.Entity;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.jetbrains.teamsys.database.TransientEntity;
import java.util.ArrayList;
import com.jetbrains.teamsys.database.EntityMetaData;
import com.jetbrains.teamsys.database.ModelMetaData;
import jetbrains.springframework.configuration.runtime.ServiceLocator;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.jetbrains.teamsys.core.execution.Job;

public class EventsMultiplexer implements TransientStoreSessionListener {
  private static EventsMultiplexer instance = new EventsMultiplexer();
  protected static Log log = LogFactory.getLog(EventsMultiplexer.class);

  private Map<EntityId, List<IEntityListener>> instanceToListeners;
  private Map<String, List<IEntityListener>> typeToListeners;
  private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

  private EventsMultiplexer() {
    this.init();
  }

  public void init() {
    this.instanceToListeners = new HashMap<EntityId, List<IEntityListener>>();
    this.typeToListeners = new HashMap<String, List<IEntityListener>>();
  }

  public void flushed(@Nullable Set<TransientEntityChange> changes) {
    this.fire(changes, false, true);
    this.asyncFire(changes);
  }

  public void commited(@Nullable Set<TransientEntityChange> changes) {
    {
      boolean $nt$_9klgcu_a0c = DnqUtils.getCurrentTransientSession() == null;
      final TransientStoreSession ts1_9klgcu_a0c = DnqUtils.beginTransientSession("commited_0");
      try {
        this.fire(changes, false, true);
      } catch (Throwable _ex_) {
        if ($nt$_9klgcu_a0c) {
          TransientStoreUtil.abort(_ex_, ts1_9klgcu_a0c);
        }
        if (_ex_ instanceof RuntimeException) {
          throw (RuntimeException) _ex_;
        } else {
          throw new RuntimeException(_ex_);
        }
      } finally {
        if ($nt$_9klgcu_a0c) {
          TransientStoreUtil.commit(ts1_9klgcu_a0c);
        }
      }
    }
    this.asyncFire(changes);
  }

  public void beforeFlushAfterConstraintsCheck(@Nullable Set<TransientEntityChange> changes) {
    // empty
  }

  public void beforeFlush(@Nullable Set<TransientEntityChange> changes) {
    // sync notify
    this.fire(changes, true, true);
  }

  private void asyncFire(final Set<TransientEntityChange> changes) {
    EventsMultiplexerJobProcessor.getInstance().queue(new EventsMultiplexer.JobImpl(this, changes));
  }

  private void fire(Set<TransientEntityChange> changes, boolean beforeFlush, boolean sync) {
    this.rwl.readLock().lock();
    try {
      for (TransientEntityChange c : changes) {
        this.handlePerEntityChanges(c, beforeFlush, sync);
        this.handlePerEntityTypeChanges(c, beforeFlush, sync);
      }
    } finally {
      this.rwl.readLock().unlock();
    }
  }

  public void addListener(final Entity e, final _FunctionTypes._void_P1_E0<? super Entity> l) {
    // for backward compatibility
    this.addListener(e, new EntityAdapter() {
      public void updatedSync(Entity old, Entity current) {
        l.invoke(e);
      }
    });
  }

  public void addListener(Entity e, final IEntityListener listener) {
    // typecast to disable generator hook
    if ((Object) e == null || listener == null) {
      if (log.isWarnEnabled()) {
        log.warn("Can't add null listener to null entity");
      }
      return;
    }
    if (((TransientEntity) e).isNew()) {
      throw new IllegalStateException("Entity is not saved into database - you can't listern to it.");
    }
    final EntityId id = e.getId();
    this.executeAsNonTransactional(new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        EventsMultiplexer.this.rwl.writeLock().lock();
        try {
          List<IEntityListener> listeners = EventsMultiplexer.this.instanceToListeners.get(id);
          if (listeners == null) {
            listeners = new ArrayList<IEntityListener>();
            EventsMultiplexer.this.instanceToListeners.put(id, listeners);
          }
          listeners.add(listener);
        } finally {
          EventsMultiplexer.this.rwl.writeLock().unlock();
        }
      }
    });
  }

  public void removeListener(Entity e, final IEntityListener listener) {
    // typecast to disable generator hook
    if ((Object) e == null || listener == null) {
      if (log.isWarnEnabled()) {
        log.warn("Can't remove null listener from null entity");
      }
      return;
    }
    final EntityId id = e.getId();
    this.executeAsNonTransactional(new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        EventsMultiplexer.this.rwl.writeLock().lock();
        try {
          final List<IEntityListener> listeners = EventsMultiplexer.this.instanceToListeners.get(id);
          if (listeners != null) {
            listeners.remove(listener);
            if (listeners.size() == 0) {
              EventsMultiplexer.this.instanceToListeners.remove(id);
            }
          }
        } finally {
          EventsMultiplexer.this.rwl.writeLock().unlock();
        }
      }
    });
  }

  public void addListener(final String entityType, final IEntityListener listener) {
    //  ensure that this code will be executed outside of transaction 
    this.executeAsNonTransactional(new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        EventsMultiplexer.this.rwl.writeLock().lock();
        try {
          List<IEntityListener> listeners = EventsMultiplexer.this.typeToListeners.get(entityType);
          if (listeners == null) {
            listeners = new ArrayList<IEntityListener>();
            EventsMultiplexer.this.typeToListeners.put(entityType, listeners);
          }
          listeners.add(listener);
        } finally {
          EventsMultiplexer.this.rwl.writeLock().unlock();
        }
      }
    });
  }

  public void removeListener(final String entityType, final IEntityListener listener) {
    this.executeAsNonTransactional(new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        EventsMultiplexer.this.rwl.writeLock().lock();
        try {
          List<IEntityListener> listeners = EventsMultiplexer.this.typeToListeners.get(entityType);
          if (listeners != null) {
            listeners.remove(listener);
            if (listeners.size() == 0) {
              EventsMultiplexer.this.typeToListeners.remove(entityType);
            }
          }
        } finally {
          EventsMultiplexer.this.rwl.writeLock().unlock();
        }
      }
    });
  }

  private void executeAsNonTransactional(_FunctionTypes._void_P0_E0 func) {
    final TransientStoreSession currentSession = DnqUtils.getCurrentTransientSession();
    if (currentSession != null) {
      currentSession.suspend();
    }
    try {
      func.invoke();
    } finally {
      if (currentSession != null) {
        DnqUtils.resumeTransientSession(currentSession);
      }
    }
  }

  private void handlePerEntityChanges(TransientEntityChange c, boolean beforeFlush, boolean sync) {
    List<IEntityListener> listeners = this.instanceToListeners.get(c.getTransientEntity().getId());
    if (listeners != null) {
      for (IEntityListener l : listeners) {
        try {
          if (beforeFlush) {
            switch (c.getChangeType()) {
              case ADD:
                l.addedSyncBeforeFlush(c.getTransientEntity());
                break;
              case UPDATE:
                l.updatedSyncBeforeFlush(TransientStoreUtil.readonlyCopy(c), c.getTransientEntity());
                break;
              case REMOVE:
                l.removedSyncBeforeFlush(TransientStoreUtil.readonlyCopy(c));
                break;
              default:
            }
          } else {
            if (sync) {
              switch (c.getChangeType()) {
                case ADD:
                  l.addedSync(c.getTransientEntity());
                  break;
                case UPDATE:
                  l.updatedSync(TransientStoreUtil.readonlyCopy(c), c.getTransientEntity());
                  break;
                case REMOVE:
                  l.removedSync(TransientStoreUtil.readonlyCopy(c));
                  break;
                default:
              }
            } else {
              switch (c.getChangeType()) {
                case ADD:
                  l.addedAsync(c.getTransientEntity());
                  break;
                case UPDATE:
                  l.updatedAsync(TransientStoreUtil.readonlyCopy(c), c.getTransientEntity());
                  break;
                case REMOVE:
                  l.removedAsync(TransientStoreUtil.readonlyCopy(c));
                  break;
                default:
              }
            }
          }
        } catch (Exception e) {
          if (log.isErrorEnabled()) {
            log.error("Exception while notifying entity listener.", e);
          }
        }
      }
    }
  }

  private void handlePerEntityTypeChanges(TransientEntityChange c, boolean beforeFlush, boolean sync) {
    EntityMetaData emd = ((ModelMetaData) ServiceLocator.getBean("modelMetaData")).getEntityMetaData(c.getTransientEntity().getType());
    if (emd != null) {
      for (String type : Sequence.fromIterable(emd.getThisAndSuperTypes())) {
        List<IEntityListener> listeners = this.typeToListeners.get(type);
        if (listeners != null) {
          for (IEntityListener l : listeners) {
            try {
              if (beforeFlush) {
                switch (c.getChangeType()) {
                  case ADD:
                    l.addedSyncBeforeFlush(c.getTransientEntity());
                    break;
                  case UPDATE:
                    l.updatedSyncBeforeFlush(TransientStoreUtil.readonlyCopy(c), c.getTransientEntity());
                    break;
                  case REMOVE:
                    l.removedSyncBeforeFlush(TransientStoreUtil.readonlyCopy(c));
                    break;
                  default:
                }
              } else {
                if (sync) {
                  switch (c.getChangeType()) {
                    case ADD:
                      l.addedSync(c.getTransientEntity());
                      break;
                    case UPDATE:
                      l.updatedSync(TransientStoreUtil.readonlyCopy(c), c.getTransientEntity());
                      break;
                    case REMOVE:
                      l.removedSync(TransientStoreUtil.readonlyCopy(c));
                      break;
                    default:
                  }
                } else {
                  switch (c.getChangeType()) {
                    case ADD:
                      l.addedAsync(c.getTransientEntity());
                      break;
                    case UPDATE:
                      l.updatedAsync(TransientStoreUtil.readonlyCopy(c), c.getTransientEntity());
                      break;
                    case REMOVE:
                      l.removedAsync(TransientStoreUtil.readonlyCopy(c));
                      break;
                    default:
                  }
                }
              }
            } catch (Exception e) {
              if (log.isErrorEnabled()) {
                log.error("Exception while notifying entity listener.", e);
              }
              // rethrow exception only for beforeFlush listeners 
              if (beforeFlush) {
                if (e instanceof RuntimeException) {
                  throw (RuntimeException) e;
                }
                throw new RuntimeException(e);
              }
            }
          }
        }
      }
    }
  }

  public static EventsMultiplexer getInstance() {
    return instance;
  }

  public static class JobImpl extends Job {
    private Set<TransientEntityChange> changes;
    private EventsMultiplexer eventsMultiplexer;

    public JobImpl(EventsMultiplexer eventsMultiplexer, Set<TransientEntityChange> changes) {
      this.eventsMultiplexer = eventsMultiplexer;
      this.changes = changes;
    }

    public void execute() throws Throwable {
      {
        boolean $nt$_9klgcu_a0a0 = DnqUtils.getCurrentTransientSession() == null;
        final TransientStoreSession ts1_9klgcu_a0a0 = DnqUtils.beginTransientSession("execute_0");
        try {
          this.eventsMultiplexer.fire(this.changes, false, false);
        } catch (Throwable _ex_) {
          if ($nt$_9klgcu_a0a0) {
            TransientStoreUtil.abort(_ex_, ts1_9klgcu_a0a0);
          }
          if (_ex_ instanceof RuntimeException) {
            throw (RuntimeException) _ex_;
          } else {
            throw new RuntimeException(_ex_);
          }
        } finally {
          if ($nt$_9klgcu_a0a0) {
            TransientStoreUtil.commit(ts1_9klgcu_a0a0);
          }
        }
      }
    }
  }
}
